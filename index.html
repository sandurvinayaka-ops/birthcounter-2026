<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Live Global Birth Tracker | Pulse</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700;900&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #010105; 
      color: #f1f5f9;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    .mono { font-family: 'JetBrains+Mono', monospace; }
    
    /* Cinematic Deep Space Background */
    .space-background {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      overflow: hidden;
      background: #010108;
    }

    .sun-glow {
      position: absolute;
      top: -10%;
      right: -10%;
      width: 70vw;
      height: 70vw;
      background: radial-gradient(circle, rgba(147, 197, 253, 0.08) 0%, transparent 70%);
      filter: blur(100px);
      pointer-events: none;
    }

    .nebula-layer {
      position: absolute;
      top: -50%; left: -50%; width: 200%; height: 200%;
      background-size: cover;
      background-position: center;
      mix-blend-mode: screen;
      pointer-events: none;
    }

    .nebula-1 {
      background-image: url('https://images.unsplash.com/photo-1464802686167-b939a6910659?q=80&w=2070&auto=format&fit=crop');
      opacity: 0.15;
      filter: blur(6px) hue-rotate(10deg);
      animation: drift-slow 180s linear infinite alternate;
    }

    .nebula-2 {
      background-image: url('https://images.unsplash.com/photo-1446776811953-b23d57bd21aa?q=80&w=2072&auto=format&fit=crop');
      opacity: 0.1;
      filter: blur(15px) saturate(1.5);
      animation: rotate-slow 240s linear infinite;
    }

    /* Star Visuals */
    .star {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
    }
    
    .star-bright {
      box-shadow: 0 0 10px 2px rgba(255,255,255,0.7), 0 0 20px 5px rgba(147, 197, 253, 0.3);
      background-color: #fff !important;
    }
    
    .star-bright::after, .star-bright::before {
      content: '';
      position: absolute;
      top: 50%; left: 50%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.6), transparent);
      transform: translate(-50%, -50%);
    }
    .star-bright::after { width: 500%; height: 1px; }
    .star-bright::before { width: 1px; height: 500%; }

    .twinkle {
      animation: twinkle-pulse var(--duration) ease-in-out infinite alternate;
    }

    @keyframes drift-slow {
      from { transform: translate(-3%, -3%) rotate(0deg); }
      to { transform: translate(3%, 3%) rotate(2deg); }
    }

    @keyframes rotate-slow {
      from { transform: rotate(0deg) scale(1.1); }
      to { transform: rotate(360deg) scale(1); }
    }

    @keyframes twinkle-pulse {
      0% { opacity: 0.2; transform: scale(0.7); filter: brightness(0.8); }
      100% { opacity: 1; transform: scale(1.1); filter: brightness(1.4); }
    }

    /* Realistic Asteroids / Meteoroids */
    .asteroid {
      position: absolute;
      z-index: 1;
      pointer-events: none;
      animation: asteroid-travel var(--speed) linear forwards;
    }

    .asteroid-body {
      width: var(--size);
      height: var(--size);
      background: #3f444d;
      /* Directional Lighting Simulation */
      background-image: radial-gradient(circle at 70% 30%, #718096 0%, #2d3748 40%, #1a202c 90%);
      clip-path: polygon(var(--path));
      box-shadow: 
        inset -12px -12px 20px rgba(0,0,0,0.9), 
        inset 10px 10px 15px rgba(255,255,255,0.1),
        0 0 10px rgba(0,0,0,0.5);
      position: relative;
      animation: asteroid-spin var(--spin-speed) linear infinite;
      overflow: hidden;
    }

    /* Multi-layered crater effects using box-shadows on pseudo-elements */
    .asteroid-body::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0; left: 0;
      opacity: 0.6;
      /* Random craters scattered across the surface */
      box-shadow: 
        inset 5px 8px 3px rgba(0,0,0,0.6),
        inset -2px -4px 3px rgba(255,255,255,0.05),
        /* Specific craters */
        var(--crater-shadows);
      border-radius: 50%;
    }

    .asteroid-trail {
      position: absolute;
      top: 50%; left: 0;
      height: 6px; 
      width: var(--trail-width);
      background: linear-gradient(90deg, 
        transparent 0%, 
        rgba(148, 163, 184, 0.1) 20%, 
        rgba(255, 255, 255, 0.2) 80%,
        rgba(255, 255, 255, 0.4) 100%
      );
      transform-origin: right center;
      transform: translateX(-100%) rotate(180deg);
      filter: blur(8px);
      mix-blend-mode: screen;
    }

    @keyframes asteroid-spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    @keyframes asteroid-travel {
      0% {
        transform: translate(var(--start-x), var(--start-y));
        opacity: 0;
      }
      15% { opacity: 1; }
      85% { opacity: 1; }
      100% {
        transform: translate(var(--end-x), var(--end-y));
        opacity: 0;
      }
    }

    /* Globe */
    .land {
      stroke: #000;
      stroke-width: 0.3;
      transition: fill 0.3s ease; 
    }

    .graticule {
      fill: none;
      stroke: #818cf8;
      stroke-width: 0.1;
      opacity: 0.08;
    }

    .globe-outline {
      fill: url(#globeGradient); 
      stroke: rgba(129, 140, 248, 0.15);
      stroke-width: 0.5px;
    }

    /* Fully Transparent UI */
    .glass-sidebar {
      background: transparent;
      backdrop-filter: none;
      border: none;
    }

    .header-spaced {
      letter-spacing: 0.3em;
      font-weight: 900;
      color: #6366f1; 
      text-shadow: 0 0 20px rgba(99, 102, 241, 0.3);
    }

    .amber-bloom {
      color: #fbbf24;
      filter: drop-shadow(0 0 30px rgba(251, 191, 36, 0.45));
      text-shadow: 0 0 10px rgba(251, 191, 36, 0.2);
    }

    /* Progress Bar Styles */
    .progress-track {
      width: 100%;
      height: 4px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      overflow: hidden;
      position: relative;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #6366f1, #fbbf24);
      box-shadow: 0 0 15px rgba(251, 191, 36, 0.5);
      transition: width 1s linear;
      position: relative;
    }
    .progress-fill::after {
      content: '';
      position: absolute;
      right: 0;
      top: 0;
      height: 100%;
      width: 4px;
      background: #fff;
      box-shadow: 0 0 10px #fff;
    }
  </style>
<script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react/": "https://esm.sh/react@^19.2.3/",
    "d3": "https://esm.sh/d3@^7.9.0",
    "lucide-react": "https://esm.sh/lucide-react@^0.562.0"
  }
}
</script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    const BIRTHS_PER_SECOND = 4.35;
    const GOLD_COLOR = "#fbbf24"; 
    const IMPACT_COLOR = "#FFFFFF"; 
    const LAND_COLOR = "#1e1b4b";
    const STROKE_COLOR = "#000";
    const ROTATION_SPEED = 0.8; 
    
    const COUNTRIES_WEIGHTS = [
      { id: 'IND', weight: 24.2 }, { id: 'CHN', weight: 9.4 },
      { id: 'NGA', weight: 8.0 }, { id: 'PAK', weight: 6.4 },
      { id: 'IDN', weight: 4.5 }, { id: 'USA', weight: 3.6 },
      { id: 'ETH', weight: 3.9 }, { id: 'BRA', weight: 2.7 },
      { id: 'BGD', weight: 3.0 }, { id: 'COD', weight: 4.1 },
      { id: 'RUS', weight: 1.4 }, { id: 'MEX', weight: 2.0 },
      { id: 'PHL', weight: 2.0 }, { id: 'EGY', weight: 2.6 },
      { id: 'VNM', weight: 1.5 }, { id: 'TUR', weight: 1.2 },
      { id: 'DEU', weight: 0.8 }, { id: 'GBR', weight: 0.7 },
      { id: 'FRA', weight: 0.7 }, { id: 'ZAF', weight: 1.2 },
      { id: 'OTHER', weight: 12.0 }
    ];

    const STELLAR_COLORS = [
      '#9bb0ff', '#aabfff', '#cad7ff', '#f8f7ff', '#fff4ea', '#ffd2a1', '#ffcc6f'
    ];

    const StarBackground = () => {
      const starLayers = useMemo(() => {
        return [
          Array.from({ length: 200 }).map((_, i) => ({
            id: `l1-${i}`, top: `${Math.random() * 100}%`, left: `${Math.random() * 100}%`,
            size: 1.2, duration: `${Math.random() * 4 + 3}s`, delay: `${Math.random() * 10}s`,
            color: STELLAR_COLORS[Math.floor(Math.random() * 3)], layer: 1
          })),
          Array.from({ length: 150 }).map((_, i) => ({
            id: `l2-${i}`, top: `${Math.random() * 100}%`, left: `${Math.random() * 100}%`,
            size: Math.random() * 2 + 1, duration: `${Math.random() * 3 + 1}s`, delay: `${Math.random() * 5}s`,
            color: STELLAR_COLORS[Math.floor(Math.random() * STELLAR_COLORS.length)], layer: 2, isBright: Math.random() > 0.85
          })),
          Array.from({ length: 30 }).map((_, i) => ({
            id: `l3-${i}`, top: `${Math.random() * 100}%`, left: `${Math.random() * 100}%`,
            size: 2.5, duration: `${Math.random() * 2 + 1}s`, delay: `${Math.random() * 2}s`,
            color: '#fff', layer: 3, isBright: true
          }))
        ];
      }, []);

      const [asteroids, setAsteroids] = useState([]);

      useEffect(() => {
        const spawnAsteroid = () => {
          const id = Date.now();
          const speed = Math.random() * 10 + 6; 
          const size = Math.random() * 80 + 40; 
          const spinSpeed = (Math.random() * 25 + 15) + 's';
          
          const startSide = Math.floor(Math.random() * 4);
          let startX, startY, endX, endY;
          const padding = 100;

          switch(startSide) {
            case 0: // Top
              startX = Math.random() * 100 + 'vw'; startY = -padding + 'vh';
              endX = (Math.random() * 100) + 'vw'; endY = (100 + padding) + 'vh';
              break;
            case 1: // Right
              startX = (100 + padding) + 'vw'; startY = Math.random() * 100 + 'vh';
              endX = -padding + 'vw'; endY = (Math.random() * 100) + 'vh';
              break;
            case 2: // Bottom
              startX = Math.random() * 100 + 'vw'; startY = (100 + padding) + 'vh';
              endX = (Math.random() * 100) + 'vw'; endY = -padding + 'vh';
              break;
            case 3: 
            default:
              startX = -padding + 'vw'; startY = Math.random() * 100 + 'vh';
              endX = (100 + padding) + 'vw'; endY = (Math.random() * 100) + 'vh';
              break;
          }

          // Generate highly jagged rocky points (16-24 vertices)
          const points = [];
          const vertexCount = 18;
          for (let i = 0; i < vertexCount; i++) {
            const angle = (i / vertexCount) * Math.PI * 2;
            const r = 30 + Math.random() * 70; 
            points.push(`${50 + Math.cos(angle) * r / 2}% ${50 + Math.sin(angle) * r / 2}%`);
          }

          // Generate unique crater positions for this rock
          const craterShadows = [];
          const craterCount = 4 + Math.floor(Math.random() * 5);
          for(let i=0; i<craterCount; i++) {
            const cx = (Math.random() * 60 - 30);
            const cy = (Math.random() * 60 - 30);
            const cr = Math.random() * 8 + 2;
            craterShadows.push(`inset ${cx}px ${cy}px ${cr}px rgba(0,0,0,0.8)`);
          }

          setAsteroids(prev => [...prev, { 
            id, startX, startY, endX, endY, 
            speed: `${speed}s`, 
            size: `${size}px`,
            spinSpeed,
            path: points.join(', '),
            craterShadows: craterShadows.join(', '),
            trailWidth: `${size * 3}px`
          }]);

          setTimeout(() => setAsteroids(prev => prev.filter(c => c.id !== id)), (speed * 1000) + 100);
          setTimeout(spawnAsteroid, 1500 + Math.random() * 4000);
        };

        const timer = setTimeout(spawnAsteroid, 500);
        return () => clearTimeout(timer);
      }, []);

      return (
        <div className="space-background">
          <div className="sun-glow"></div>
          <div className="nebula-layer nebula-1"></div>
          <div className="nebula-layer nebula-2"></div>
          
          {starLayers.flat().map(star => (
            <div 
              key={star.id} 
              className={`star twinkle ${star.isBright ? 'star-bright' : ''}`} 
              style={{
                top: star.top, left: star.left,
                width: `${star.size}px`, height: `${star.size}px`,
                backgroundColor: star.color,
                '--duration': star.duration,
                animationDelay: star.delay,
                opacity: star.layer === 1 ? 0.4 : 0.9,
                zIndex: star.layer
              }}
            />
          ))}

          {asteroids.map(ast => (
            <div 
              key={ast.id}
              className="asteroid"
              style={{
                '--start-x': ast.startX, '--start-y': ast.startY,
                '--end-x': ast.endX, '--end-y': ast.endY,
                '--speed': ast.speed
              }}
            >
              <div className="asteroid-body" style={{ 
                '--size': ast.size, 
                '--path': ast.path,
                '--spin-speed': ast.spinSpeed,
                '--crater-shadows': ast.craterShadows
              }}></div>
              <div className="asteroid-trail" style={{ '--trail-width': ast.trailWidth }}></div>
            </div>
          ))}
        </div>
      );
    };

    const WorldMap = ({ lastBirth }) => {
      const svgRef = useRef(null);
      const [geoData, setGeoData] = useState(null);
      const rotationRef = useRef([0, -12]); 
      const activeFlashesRef = useRef(new Map()); 

      useEffect(() => {
        fetch('https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson')
          .then(res => res.json())
          .then(data => {
            const filteredFeatures = data.features.filter(feature => feature.id !== 'ATA');
            setGeoData({ ...data, features: filteredFeatures });
          });
      }, []);

      useEffect(() => {
        if (!geoData || !svgRef.current) return;

        const svg = d3.select(svgRef.current);
        const width = svgRef.current.clientWidth;
        const height = svgRef.current.clientHeight;

        svg.selectAll("*").remove();
        const defs = svg.append("defs");
        
        const globeGrad = defs.append("radialGradient")
          .attr("id", "globeGradient")
          .attr("cx", "75%")
          .attr("cy", "25%")
          .attr("r", "70%");
        globeGrad.append("stop").attr("offset", "0%").attr("stop-color", "#0f172a");
        globeGrad.append("stop").attr("offset", "100%").attr("stop-color", "#020617");

        const globeRadius = Math.min(width, height) / 2.3;
        const projection = d3.geoOrthographic()
          .scale(globeRadius)
          .translate([width / 2, height / 2])
          .clipAngle(90);

        const path = d3.geoPath().projection(projection);
        
        svg.append("path")
          .datum({type: "Sphere"})
          .attr("class", "globe-outline")
          .attr("d", path);

        const graticule = d3.geoGraticule();
        const graticulePath = svg.append("path")
          .datum(graticule)
          .attr("class", "graticule")
          .attr("d", path);

        const mapGroup = svg.append("g");
        const countries = mapGroup.selectAll("path")
          .data(geoData.features)
          .enter()
          .append("path")
          .attr("d", path)
          .attr("class", d => `land country-${d.id}`)
          .attr("fill", LAND_COLOR)
          .attr("stroke", STROKE_COLOR);

        const timer = d3.timer((elapsed) => {
          rotationRef.current[0] += ROTATION_SPEED;
          projection.rotate(rotationRef.current);

          graticulePath.attr("d", path);
          svg.select(".globe-outline").attr("d", path);

          const now = Date.now();
          countries.each(function(d) {
            const countryPath = d3.select(this);
            countryPath.attr("d", path);

            const centroid = d3.geoCentroid(d);
            const visible = projection.clipAngle() === null || d3.geoDistance(centroid, [-rotationRef.current[0], -rotationRef.current[1]]) < Math.PI / 2;
            
            if (!visible) {
              countryPath.attr("opacity", 0);
              return;
            }
            countryPath.attr("opacity", 1);

            const flash = activeFlashesRef.current.get(d.id);
            if (flash) {
              const age = now - flash.startTime;
              if (age > 2000) {
                activeFlashesRef.current.delete(d.id);
                countryPath.attr("fill", LAND_COLOR).attr("stroke", STROKE_COLOR).style("filter", "none");
              } else {
                let color;
                if (age < 50) {
                  color = IMPACT_COLOR;
                  countryPath.style("filter", `drop-shadow(0 0 25px ${GOLD_COLOR}) brightness(2.5)`);
                } else {
                  const t = (age - 50) / 1950;
                  color = d3.interpolateRgb(GOLD_COLOR, LAND_COLOR)(t);
                  countryPath.style("filter", t < 0.5 ? `drop-shadow(0 0 ${15 * (1-t)}px ${GOLD_COLOR})` : "none");
                }
                countryPath.attr("fill", color).attr("stroke", color);
              }
            }
          });
        });

        const handleResize = () => {
          if (!svgRef.current) return;
          const w = svgRef.current.clientWidth;
          const h = svgRef.current.clientHeight;
          projection.scale(Math.min(w, h) / 2.3).translate([w / 2, h / 2]);
        };

        window.addEventListener('resize', handleResize);
        return () => {
          timer.stop();
          window.removeEventListener('resize', handleResize);
        };
      }, [geoData]);

      useEffect(() => {
        if (!lastBirth || !geoData) return;
        let targetId = lastBirth.countryId;
        if (targetId === "OTHER") {
          const others = geoData.features.filter(f => !COUNTRIES_WEIGHTS.some(c => c.id === f.id));
          if (others.length > 0) targetId = others[Math.floor(Math.random() * others.length)].id;
        }
        activeFlashesRef.current.set(targetId, { startTime: Date.now() });
      }, [lastBirth]);

      return (
        <div className="relative w-full h-full flex items-center justify-center">
          <div className="absolute w-[62vh] h-[62vh] rounded-full border border-indigo-500/10 bg-indigo-500/5 blur-[80px] pointer-events-none"></div>
          <div className="absolute w-[58vh] h-[58vh] rounded-full ring-1 ring-blue-400/20 blur-[2px] pointer-events-none"></div>
          <svg ref={svgRef} className="w-full h-full relative z-10" />
        </div>
      );
    };

    const App = () => {
      const [totalToday, setTotalToday] = useState(0);
      const [lastBirth, setLastBirth] = useState(null);
      const [dayProgress, setDayProgress] = useState(0);
      const [currentTime, setCurrentTime] = useState('');
      const totalTodayRef = useRef(0);

      useEffect(() => {
        const updateProgress = () => {
          const now = new Date();
          const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
          const secondsElapsed = (now.getTime() - startOfDay.getTime()) / 1000;
          setDayProgress((secondsElapsed / 86400) * 100);
          
          const hh = String(now.getHours()).padStart(2, '0');
          const mm = String(now.getMinutes()).padStart(2, '0');
          setCurrentTime(`${hh}:${mm}`);
        };

        const now = new Date();
        const startOfDay = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const initialCount = Math.floor(((now.getTime() - startOfDay.getTime()) / 1000) * BIRTHS_PER_SECOND);
        setTotalToday(initialCount);
        totalTodayRef.current = initialCount;
        updateProgress();

        const progressInterval = setInterval(updateProgress, 1000);

        const schedule = () => {
          const delay = -Math.log(Math.random()) * (1000 / BIRTHS_PER_SECOND);
          setTimeout(() => {
            const totalWeight = COUNTRIES_WEIGHTS.reduce((acc, c) => acc + c.weight, 0);
            let r = Math.random() * totalWeight;
            let selectedId = "OTHER";
            for (const c of COUNTRIES_WEIGHTS) {
              if (r < c.weight) { selectedId = c.id; break; }
              r -= c.weight;
            }
            totalTodayRef.current += 1;
            setTotalToday(totalTodayRef.current);
            setLastBirth({ countryId: selectedId, timestamp: Date.now() });
            schedule();
          }, delay);
        };
        schedule();

        return () => clearInterval(progressInterval);
      }, []);

      return (
        <div className="h-screen w-screen flex flex-col bg-transparent overflow-hidden">
          <StarBackground />
          <div className="flex-1 flex overflow-hidden">
            <div className="w-[40%] flex flex-col justify-center items-center p-12 relative glass-sidebar z-10">
              <div className="w-full max-w-xl text-center">
                <div className="header-spaced text-3xl uppercase mb-6 leading-tight font-black opacity-70">
                  Global<br/>Live Births
                </div>
                <div className="text-[7.5vw] font-black amber-bloom mono leading-none tracking-tighter whitespace-nowrap mb-8">
                  {new Intl.NumberFormat('de-DE').format(totalToday)}
                </div>
                
                {/* 24-Hour Progress Bar Container */}
                <div className="w-[70%] mx-auto mt-4 text-left relative">
                   <div className="h-6 relative w-full mb-1">
                      <div 
                        className="absolute bottom-0 text-[10px] font-black text-white mono whitespace-nowrap transition-all duration-1000 linear" 
                        style={{ left: `${dayProgress}%`, transform: 'translateX(-50%)' }}
                      >
                        {currentTime}
                      </div>
                   </div>
                   <div className="progress-track">
                     <div className="progress-fill" style={{ width: `${dayProgress}%` }}></div>
                   </div>
                   <div className="flex justify-between mt-1 text-[8px] font-bold text-slate-500 uppercase tracking-tighter">
                     <span>00:00</span>
                     <span>24:00</span>
                   </div>
                </div>
              </div>
            </div>

            <div className="flex-1 relative">
               <WorldMap lastBirth={lastBirth} />
            </div>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>