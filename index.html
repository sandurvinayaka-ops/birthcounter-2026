<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Global Birth Tracker | Live Cinematic Visualization</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&family=JetBrains+Mono:wght@500;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #000002; 
      color: #f8fafc;
      margin: 0;
      padding: 0;
      overflow: hidden;
    }
    .mono { font-family: 'JetBrains+Mono', monospace; }
    
    .space-container {
      position: fixed;
      top: 0; left: 0; width: 100%; height: 100%;
      z-index: -1;
      background: #000005;
      overflow: hidden;
    }

    .nebula {
      position: absolute;
      width: 160%; height: 160%;
      top: -30%; left: -30%;
      background: 
        radial-gradient(circle at 70% 30%, rgba(37, 99, 235, 0.15) 0%, transparent 60%),
        radial-gradient(circle at 30% 70%, rgba(126, 34, 206, 0.12) 0%, transparent 60%),
        radial-gradient(circle at 50% 50%, rgba(2, 6, 23, 0.4) 0%, transparent 70%);
      filter: blur(120px);
      animation: drift 160s linear infinite alternate;
      opacity: 0.9;
    }

    @keyframes drift {
      from { transform: translate(-5%, -5%) rotate(0deg); }
      to { transform: translate(5%, 5%) rotate(6deg); }
    }

    .star {
      position: absolute;
      border-radius: 50%;
      pointer-events: none;
    }

    @keyframes star-twinkle {
      0%, 100% { opacity: 0.2; transform: scale(0.6); filter: brightness(1); }
      50% { opacity: 1; transform: scale(1.3); filter: brightness(2.5) drop-shadow(0 0 6px white); }
    }

    .star-twinkle {
      animation: star-twinkle var(--duration) ease-in-out infinite;
    }

    .comet {
      position: absolute;
      width: 3px;
      height: 3px;
      background: #fff;
      border-radius: 50%;
      box-shadow: 0 0 15px 4px rgba(255, 255, 255, 0.8);
      filter: drop-shadow(0 0 15px rgba(59, 130, 246, 0.6));
      z-index: 5;
    }

    .comet::after {
      content: '';
      position: absolute;
      top: 50%;
      right: 0;
      transform: translateY(-50%);
      width: 180px;
      height: 2px;
      background: linear-gradient(to left, rgba(255,255,255,0.9), transparent);
    }

    @keyframes fly {
      from { transform: translate(-150px, -150px) rotate(45deg); opacity: 0; }
      20% { opacity: 1; }
      80% { opacity: 1; }
      to { transform: translate(140vw, 100vh) rotate(45deg); opacity: 0; }
    }

    .glass-sidebar {
      background: linear-gradient(90deg, rgba(0,0,0,1) 0%, rgba(0,0,0,0.8) 40%, transparent 100%);
    }

    .counter-glow {
      color: #fbbf24;
      font-weight: 800;
      text-shadow: 0 0 45px rgba(251, 191, 36, 0.5), 0 0 150px rgba(251, 191, 36, 0.25);
      letter-spacing: -0.06em;
      line-height: 0.8;
    }

    .progress-track {
      height: 12px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 100px;
      width: 100%;
      position: relative;
      box-shadow: inset 0 2px 6px rgba(0,0,0,0.5);
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #6366f1, #eab308, #fbbf24);
      box-shadow: 0 0 30px rgba(251, 191, 36, 0.5);
      transition: width 1s linear;
      border-radius: 100px;
    }

    .time-label-container {
      position: absolute;
      bottom: 30px; 
      transform: translateX(-50%);
      transition: left 1s linear;
      text-align: center;
    }

    .time-label {
      font-size: 1.4rem;
      color: #ffffff;
      font-weight: 800;
      font-family: 'JetBrains+Mono', monospace;
      text-shadow: 0 0 20px black, 0 0 8px rgba(255,255,255,0.4);
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useMemo } = React;

    const BIRTHS_PER_SECOND = 4.35;
    const FLASH_BURST_COLOR = "#FFFFFF"; 
    const FLASH_BLOOM_COLOR = "#fbbf24"; 
    const LAND_COLOR = "#334155"; 
    const OCEAN_COLOR = "#070b1a"; 
    const ROTATION_SPEED = 0.65; // High speed smooth rotation

    const generateStars = (count) => {
      const colors = ['#ffffff', '#e2e8f0', '#fbbf24', '#cbd5e1', '#fecaca', '#bfdbfe', '#fff'];
      return Array.from({ length: count }).map((_, i) => ({
        id: i,
        top: `${Math.random() * 100}%`,
        left: `${Math.random() * 100}%`,
        size: Math.random() * 3.0 + 0.4,
        color: colors[Math.floor(Math.random() * colors.length)],
        duration: `${Math.random() * 3 + 1.2}s`,
        delay: `${Math.random() * -10}s`
      }));
    };

    const SpaceBackground = () => {
      const stars = useMemo(() => generateStars(650), []); // Increased density
      const [comets, setComets] = useState([]);

      useEffect(() => {
        const interval = setInterval(() => {
          if (Math.random() > 0.6) {
            const id = Date.now();
            const startX = Math.random() * 60;
            const startY = Math.random() * -20;
            setComets(prev => [...prev, { id, startX, startY }]);
            setTimeout(() => {
              setComets(prev => prev.filter(c => c.id !== id));
            }, 6000);
          }
        }, 4000);
        return () => clearInterval(interval);
      }, []);

      return (
        <div className="space-container">
          <div className="nebula"></div>
          {stars.map(s => (
            <div 
              key={s.id} 
              className="star star-twinkle" 
              style={{
                top: s.top, 
                left: s.left, 
                width: `${s.size}px`, 
                height: `${s.size}px`,
                backgroundColor: s.color,
                '--duration': s.duration,
                animationDelay: s.delay,
                boxShadow: s.size > 2.0 ? `0 0 10px ${s.color}` : 'none'
              }}
            />
          ))}
          {comets.map(c => (
            <div 
              key={c.id} 
              className="comet" 
              style={{
                left: `${c.startX}%`,
                top: `${c.startY}%`,
                animation: 'fly 6s linear forwards'
              }}
            />
          ))}
        </div>
      );
    };

    const Globe = ({ lastBirth }) => {
      const canvasRef = useRef(null);
      const [geoData, setGeoData] = useState(null);
      const rotationRef = useRef([0, -12]); 
      const flashesRef = useRef(new Map());
      const animationRef = useRef();

      useEffect(() => {
        fetch('https://raw.githubusercontent.com/holtzy/D3-graph-gallery/master/DATA/world.geojson')
          .then(res => res.json())
          .then(data => setGeoData(data));
      }, []);

      useEffect(() => {
        if (!geoData || !canvasRef.current) return;
        const canvas = canvasRef.current;
        const context = canvas.getContext('2d');
        const dpr = window.devicePixelRatio || 1;

        const resize = () => {
          const { clientWidth, clientHeight } = canvas.parentElement;
          canvas.width = clientWidth * dpr;
          canvas.height = clientHeight * dpr;
          canvas.style.width = `${clientWidth}px`;
          canvas.style.height = `${clientHeight}px`;
          context.scale(dpr, dpr);
        };
        resize();
        window.addEventListener('resize', resize);

        const render = () => {
          const w = canvas.width / dpr;
          const h = canvas.height / dpr;
          const radius = Math.min(w, h) * 0.44;
          
          // Adjusted cx slightly to the left from 0.76 to 0.68 (bringing it closer to text)
          const cx = w * 0.68; 
          const cy = h * 0.5;

          const projection = d3.geoOrthographic().scale(radius).translate([cx, cy]).clipAngle(90);
          const path = d3.geoPath(projection, context);

          context.clearRect(0, 0, w, h);
          rotationRef.current[0] += ROTATION_SPEED;
          projection.rotate(rotationRef.current);

          // Atmospheric Glow
          const bloom = context.createRadialGradient(cx, cy, radius, cx, cy, radius + 140);
          bloom.addColorStop(0, 'rgba(59, 130, 246, 0.25)');
          bloom.addColorStop(0.5, 'rgba(59, 130, 246, 0.08)');
          bloom.addColorStop(1, 'transparent');
          context.fillStyle = bloom;
          context.beginPath(); context.arc(cx, cy, radius + 140, 0, Math.PI * 2); context.fill();

          // Globe Sphere Base
          context.beginPath(); context.arc(cx, cy, radius, 0, Math.PI * 2);
          context.fillStyle = OCEAN_COLOR; context.fill();
          
          // Ocean Depth Highlight
          const depth = context.createRadialGradient(cx - radius * 0.3, cy - radius * 0.3, radius * 0.3, cx, cy, radius);
          depth.addColorStop(0, '#1d4ed8');
          depth.addColorStop(1, OCEAN_COLOR);
          context.fillStyle = depth;
          context.fill();

          const now = Date.now();
          geoData.features.forEach(f => {
            const centroid = d3.geoCentroid(f);
            const isVisible = d3.geoDistance(centroid, [-rotationRef.current[0], -rotationRef.current[1]]) < Math.PI/2.05;
            if (isVisible) {
              context.beginPath(); path(f);
              const flash = flashesRef.current.get(f.id);
              if (flash) {
                const age = now - flash.start;
                if (age > 1300) { 
                  flashesRef.current.delete(f.id); 
                  context.fillStyle = LAND_COLOR; 
                } else {
                  const t = age / 1300;
                  context.fillStyle = age < 70 ? FLASH_BURST_COLOR : d3.interpolateRgb(FLASH_BLOOM_COLOR, LAND_COLOR)(t);
                  context.shadowBlur = 50 * (1 - t);
                  context.shadowColor = FLASH_BLOOM_COLOR;
                }
              } else {
                context.fillStyle = LAND_COLOR;
                context.shadowBlur = 0;
              }
              context.fill();
              
              context.strokeStyle = 'rgba(255,255,255,0.12)';
              context.lineWidth = 0.5;
              context.stroke();
            }
          });

          // Glossy Surface Effect
          const spec = context.createRadialGradient(cx - radius * 0.4, cy - radius * 0.4, radius * 0.05, cx, cy, radius);
          spec.addColorStop(0, 'rgba(255,255,255,0.25)');
          spec.addColorStop(0.6, 'rgba(0,0,0,0)');
          spec.addColorStop(1, 'rgba(0,0,0,0.6)');
          context.fillStyle = spec;
          context.beginPath(); context.arc(cx, cy, radius, 0, Math.PI * 2); context.fill();

          animationRef.current = requestAnimationFrame(render);
        };
        render();
        return () => {
          window.removeEventListener('resize', resize);
          cancelAnimationFrame(animationRef.current);
        };
      }, [geoData]);

      useEffect(() => {
        if (!lastBirth || !geoData) return;
        flashesRef.current.set(lastBirth.countryId, { start: Date.now() });
      }, [lastBirth]);

      return <div className="w-full h-full"><canvas ref={canvasRef} /></div>;
    };

    const App = () => {
      const [totalToday, setTotalToday] = useState(0);
      const [lastBirth, setLastBirth] = useState(null);
      const [time, setTime] = useState({ label: "00:00", pct: 0 });
      const count = useRef(0);

      useEffect(() => {
        const updateTime = () => {
          const d = new Date();
          const midnight = new Date(d.getFullYear(), d.getMonth(), d.getDate()).getTime();
          const elapsed = (d.getTime() - midnight) / 1000;
          const pct = (elapsed / 86400) * 100;
          setTime({ 
            label: d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: false }), 
            pct 
          });
          if (count.current === 0) {
            count.current = Math.floor(elapsed * BIRTHS_PER_SECOND);
            setTotalToday(count.current);
          }
        };
        updateTime();
        const t = setInterval(updateTime, 1000);

        const spawn = () => {
          const delay = -Math.log(Math.random()) * (1000 / BIRTHS_PER_SECOND);
          setTimeout(() => {
            count.current++;
            setTotalToday(count.current);
            const countries = ['IND', 'CHN', 'NGA', 'PAK', 'IDN', 'USA', 'ETH', 'BRA', 'BGD', 'COD', 'MEX', 'EGY', 'PHL', 'VNM', 'TUR'];
            setLastBirth({ countryId: countries[Math.floor(Math.random() * countries.length)], ts: Date.now() });
            spawn();
          }, delay);
        };
        spawn();
        return () => clearInterval(t);
      }, []);

      return (
        <div className="h-screen w-screen relative overflow-hidden bg-black">
          <SpaceBackground />
          <div className="absolute inset-0 z-10"><Globe lastBirth={lastBirth} /></div>
          
          <div className="absolute top-0 left-0 bottom-0 w-1/2 flex flex-col justify-center pl-32 z-20 glass-sidebar pointer-events-none">
            <div className="pointer-events-auto flex flex-col max-w-fit text-left">
              
              <div className="mb-4">
                <div className="text-[0.75rem] uppercase tracking-[0.6em] text-blue-400 font-bold opacity-90">
                  Births Since Midnight
                </div>
              </div>

              <div className="mb-14">
                <div className="text-[10vw] counter-glow mono tabular-nums">
                  {new Intl.NumberFormat('en-US').format(totalToday)}
                </div>
              </div>

              <div className="relative w-full pt-16 max-w-2xl">
                <div className="time-label-container" style={{ left: `${time.pct}%` }}>
                  <div className="time-label">{time.label}</div>
                </div>
                <div className="progress-track">
                  <div className="progress-fill" style={{ width: `${time.pct}%` }}></div>
                </div>
              </div>

            </div>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>